# üìÖ Simple RRule - Scheduler Documentation

**Complete documentation of the recurrence rule expansion system (expandRrule.ts)**

This document details the functionalities of the `expandRrule.ts` module, responsible for expanding RRule rules into concrete events within specific periods.

---

## üéØ Overview

The `expandRrule.ts` module is the heart of the scheduling system, transforming abstract recurrence rules into concrete lists of events with specific dates. It supports all frequencies from the RFC 5545 standard and offers advanced features like `BYSETPOS`, `BYMONTHDAY`, and automatic validation.

## üèóÔ∏è Interfaces and Types

### `IDateEvents`
Interface representing an individual event generated by expansion:

```typescript
interface IDateEvents {
    date: Date      // Specific event date
    index: number   // Sequential event index (1, 2, 3...)
}
```

### `IExpandResult`
Interface that encapsulates the complete expansion result:

```typescript
interface IExpandResult {
    r: IRuleExtended        // Processed and validated rule
    events: IDateEvents[]   // List of generated events
}
```

### `IRuleExtended`
Extension of the `IRrule` interface with internally calculated fields:

```typescript
interface IRuleExtended extends IRrule {
    startRangePeriod: Date           // Effective period start
    endRangePeriodOrUntil: Date      // Effective end (considering UNTIL)
    secondsDuration: number          // Duration in seconds
    hasErrors: boolean               // Indicates validation errors
    errorMessages: string            // Detailed error messages
    eventsCount: number              // Event counter
    startIndexCount: number          // Initial index for counting
    firstEventInRangePeriod: Date    // First event in the period
}
```

## üîß Main Functions

### `expandRRule()`
**Main function for RRule expansion**

```typescript
expandRRule(
    rRulePayload: IRrule,           // RRule to be expanded
    startRangePeriod: Date,         // Search period start
    endRangePeriod: Date,           // Search period end
    minimalSecondsDuration?: number // Minimum duration (default: 5 minutes)
): IExpandResult
```

**Features:**
- ‚úÖ Validates input RRule
- ‚úÖ Adjusts periods considering `UNTIL` and `COUNT`
- ‚úÖ Calculates events based on frequency
- ‚úÖ Applies period and count filters
- ‚úÖ Returns ordered events with indices

**Example:**
```typescript
import { expandRRule } from 'simple-rrule'

const rRule = {
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z'),
    frequency: 'WEEKLY',
    interval: 1,
    byDay: 'MO,WE,FR',
    count: 10,
    wkst: 'SU'
}

const result = expandRRule(
    rRule,
    new Date('2023-12-01'),
    new Date('2024-01-31')
)

console.log(`${result.events.length} events found`)
result.events.forEach(event => {
    console.log(`Event ${event.index}: ${event.date.toISOString()}`)
})
```

### `expandRRuleFromString()`
**Convenience function for expansion from RRule strings**

```typescript
expandRRuleFromString(
    rRuleString: string,      // Complete RRule string
    startRangePeriod: Date,   // Period start
    endRangePeriod: Date      // Period end
): IExpandResult
```

**Example:**
```typescript
const rRuleString = `
DTSTART:20231201T100000Z
DTEND:20231201T110000Z
RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5
`

const result = expandRRuleFromString(
    rRuleString,
    new Date('2023-12-01'),
    new Date('2023-12-31')
)
```

## üìä Supported Frequencies

### 1. **MINUTELY** - Every N minutes
```typescript
// Every 30 minutes for 2 hours
const rule = {
    frequency: 'MINUTELY',
    interval: 30,
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T10:01:00Z'),
    count: 4
}

const result = expandRRule(rule, new Date('2023-12-01'), new Date('2023-12-01T23:59:59Z'))
// Result: 4 events
// [
//   { date: 2023-12-01T10:00:00.000Z, index: 1 },
//   { date: 2023-12-01T10:30:00.000Z, index: 2 },
//   { date: 2023-12-01T11:00:00.000Z, index: 3 },
//   { date: 2023-12-01T11:30:00.000Z, index: 4 }
// ]
```

### 2. **HOURLY** - Every N hours
```typescript
// Every 3 hours for 24 hours
const rule = {
    frequency: 'HOURLY',
    interval: 3,
    dtStart: new Date('2023-12-01T00:00:00Z'),
    dtEnd: new Date('2023-12-01T01:00:00Z'),
    count: 8
}

const result = expandRRule(rule, new Date('2023-12-01'), new Date('2023-12-02'))
// Result: 8 events
// [
//   { date: 2023-12-01T00:00:00.000Z, index: 1 },
//   { date: 2023-12-01T03:00:00.000Z, index: 2 },
//   { date: 2023-12-01T06:00:00.000Z, index: 3 },
//   { date: 2023-12-01T09:00:00.000Z, index: 4 },
//   { date: 2023-12-01T12:00:00.000Z, index: 5 },
//   { date: 2023-12-01T15:00:00.000Z, index: 6 },
//   { date: 2023-12-01T18:00:00.000Z, index: 7 },
//   { date: 2023-12-01T21:00:00.000Z, index: 8 }
// ]
```

### 3. **DAILY** - Every N days
```typescript
// Every day for 1 week
const rule = {
    frequency: 'DAILY',
    interval: 1,
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z'),
    count: 7
}

const result = expandRRule(rule, new Date('2023-12-01'), new Date('2023-12-31'))
// Result: 7 events
// [
//   { date: 2023-12-01T10:00:00.000Z, index: 1 },
//   { date: 2023-12-02T10:00:00.000Z, index: 2 },
//   { date: 2023-12-03T10:00:00.000Z, index: 3 },
//   { date: 2023-12-04T10:00:00.000Z, index: 4 },
//   { date: 2023-12-05T10:00:00.000Z, index: 5 },
//   { date: 2023-12-06T10:00:00.000Z, index: 6 },
//   { date: 2023-12-07T10:00:00.000Z, index: 7 }
// ]
```

### 4. **WEEKLY** - Every N weeks
```typescript
// Every Monday, Wednesday and Friday for 4 weeks
const rule = {
    frequency: 'WEEKLY',
    interval: 1,
    byDay: 'MO,WE,FR',
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z'),
    count: 12,
    wkst: 'SU'
}
```

### 5. **MONTHLY** - Every N months
```typescript
// Every 15th day of each month for 6 months
const rule = {
    frequency: 'MONTHLY',
    interval: 1,
    byMonthDay: 15,
    dtStart: new Date('2023-12-15T10:00:00Z'),
    dtEnd: new Date('2023-12-15T11:00:00Z'),
    count: 6
}
```

### 6. **YEARLY** - Every N years
```typescript
// Every December 25th
const rule = {
    frequency: 'YEARLY',
    interval: 1,
    byMonth: 12,
    byMonthDay: 25,
    dtStart: new Date('2023-12-25T00:00:00Z'),
    dtEnd: new Date('2023-12-25T01:00:00Z')
}
```

## üéØ Advanced Features

### **BYSETPOS** - Position in Sequence
Allows selecting specific occurrences within a set:

```typescript
// Second Monday of each month
const rule = {
    frequency: 'MONTHLY',
    interval: 1,
    byDay: 'MO',
    bySetPos: 2,  // Second occurrence
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z')
}

// Last Friday of March each year
const rule2 = {
    frequency: 'YEARLY',
    interval: 1,
    byMonth: 3,
    byDay: 'FR',
    bySetPos: -1,  // Last occurrence
    dtStart: new Date('2023-03-01T10:00:00Z'),
    dtEnd: new Date('2023-03-01T11:00:00Z')
}
```

**Supported values:**
- `1, 2, 3, 4`: First, second, third, fourth occurrence
- `-1`: Last occurrence

### **BYMONTHDAY** - Specific Day of Month
```typescript
// Every 1st and 15th of each month
const rule = {
    frequency: 'MONTHLY',
    interval: 1,
    byMonthDay: 1,  // Or 15
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z')
}
```

### **BYMONTH** - Specific Month
```typescript
// Every December (yearly)
const rule = {
    frequency: 'YEARLY',
    interval: 1,
    byMonth: 12,
    byMonthDay: 25,
    dtStart: new Date('2023-12-25T10:00:00Z'),
    dtEnd: new Date('2023-12-25T11:00:00Z')
}
```

### **BYDAY** - Days of Week
```typescript
// Mondays, Wednesdays and Fridays
const rule = {
    frequency: 'WEEKLY',
    interval: 1,
    byDay: 'MO,WE,FR',
    dtStart: new Date('2023-12-01T10:00:00Z'),
    dtEnd: new Date('2023-12-01T11:00:00Z'),
    wkst: 'SU'  // Week starts on Sunday
}
```

**Day codes:**
- `SU`: Sunday
- `MO`: Monday
- `TU`: Tuesday
- `WE`: Wednesday
- `TH`: Thursday
- `FR`: Friday
- `SA`: Saturday

## üîç Internal Algorithms

### **Index Calculation**
The system automatically calculates event indices, considering:
- Events prior to the search period
- Intervals between recurrences
- `COUNT` limitations

### **Performance Optimization**
- **Pre-calculation**: Determines the first event in the period without generating all previous ones
- **Efficient filtering**: Applies filters during generation, not after
- **Prior validation**: Avoids unnecessary processing on invalid rules

### **Period Handling**
```typescript
// The system automatically adjusts periods considering:
// 1. UNTIL vs endRangePeriod (uses the smaller)
// 2. dtStart vs startRangePeriod (uses the larger)
// 3. Event duration (subtracts from end date)
```

## ‚ö†Ô∏è Validations and Error Handling

### **Automatic Validations**
- ‚úÖ `dtStart` must be before `dtEnd`
- ‚úÖ `interval` must be greater than 0
- ‚úÖ `until` must be after `dtStart`
- ‚úÖ Valid weekday codes
- ‚úÖ `bySetPos` values within range (-1, 1-4)

### **Error Handling**
```typescript
const result = expandRRule(invalidRule, start, end)

if (result.r.hasErrors) {
    console.error('Errors found:', result.r.errorMessages)
    console.log('Events generated:', result.events.length) // Will be 0
}
```

### **Special Cases**
- **Rules without events**: Returns empty array
- **Invalid periods**: Marks as error and returns empty
- **COUNT exceeded**: Stops generation automatically
- **UNTIL in the past**: Considers only valid events

## üìà Advanced Practical Examples

### **Smart Backup System**
```typescript
// Daily backup on weekdays
const backupRule = {
    frequency: 'WEEKLY',
    interval: 1,
    byDay: 'MO,TU,WE,TH,FR',
    dtStart: new Date('2023-12-01T02:00:00Z'),
    dtEnd: new Date('2023-12-01T02:30:00Z'),
    wkst: 'SU'
}

const backups = expandRRule(
    backupRule,
    new Date('2023-12-01'),
    new Date('2024-01-31')
)

console.log(`${backups.events.length} backups scheduled`)
```

### **Complex Corporate Meetings**
```typescript
// First Monday of each month at 2 PM
const monthlyMeeting = {
    frequency: 'MONTHLY',
    interval: 1,
    byDay: 'MO',
    bySetPos: 1,
    dtStart: new Date('2023-12-04T14:00:00Z'),
    dtEnd: new Date('2023-12-04T16:00:00Z')
}

const meetings = expandRRule(
    monthlyMeeting,
    new Date('2023-12-01'),
    new Date('2024-12-31')
)
```

### **Quarterly Maintenance**
```typescript
// Every 3 months on the 1st
const maintenance = {
    frequency: 'MONTHLY',
    interval: 3,
    byMonthDay: 1,
    dtStart: new Date('2024-01-01T00:00:00Z'),
    dtEnd: new Date('2024-01-01T04:00:00Z'),
    count: 4  // Only 4 maintenances
}

const maintenances = expandRRule(
    maintenance,
    new Date('2024-01-01'),
    new Date('2024-12-31')
)
```

## üß™ Testing and Validation

The module has **583 automated tests** covering:

- ‚úÖ All frequencies (MINUTELY to YEARLY)
- ‚úÖ BYSETPOS combinations with different frequencies
- ‚úÖ Period and counter validation
- ‚úÖ Edge cases and limits
- ‚úÖ Performance with large volumes
- ‚úÖ Integration with different time zones

### **Running Tests**
```bash
# All tests
npm test

# Only expandRrule tests
npm test expandRrule
```

## üöÄ Performance and Optimizations

### **Typical Benchmarks**
- **Daily events for 1 year**: ~1ms
- **Weekly events for 5 years**: ~2ms
- **Monthly events for 10 years**: ~5ms
- **Complex BYSETPOS for 1 year**: ~10ms

### **Performance Tips**
1. **Use specific periods**: Avoid unnecessarily broad periods
2. **Prefer COUNT to UNTIL**: More efficient for finite sequences
3. **BYSETPOS**: Use only when necessary (more expensive)
4. **Cache results**: For repetitive rules, consider caching

## üìö Technical References

- **RFC 5545**: [Internet Calendaring and Scheduling Core Object Specification](https://tools.ietf.org/html/rfc5545)
- **Date algorithms**: Based on optimized libraries
- **Validation**: Powered by Zod for type safety

---

**Simple RRule Scheduler** - Transforming rules into real events with precision and performance! üéØ